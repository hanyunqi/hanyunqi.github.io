<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hanyunqi的博客</title>
  <icon>https://www.gravatar.com/avatar/3735598029b325cb6e01c422b4b18d4a</icon>
  <subtitle>Keep It Simple, Stupid!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hanyunqi.me/"/>
  <updated>2020-03-24T16:51:23.966Z</updated>
  <id>http://hanyunqi.me/</id>
  
  <author>
    <name>hanyunqi</name>
    <email>hanyunqi1989@foxmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>FUSE架构及性能分析</title>
    <link href="http://hanyunqi.me/2020/03/23/performance-of-fuse/"/>
    <id>http://hanyunqi.me/2020/03/23/performance-of-fuse/</id>
    <published>2020-03-23T08:08:33.000Z</published>
    <updated>2020-03-24T16:51:23.966Z</updated>
    
    <content type="html"><![CDATA[<p>最近在研究FUSE（User-Space File Systems），网上相关的资料大多比较浅显。有两篇不错的论文：<a href="https://libfuse.github.io/doxygen/fast17-vangoor.pdf" target="_blank" rel="noopener">《To FUSE or Not to FUSE: Performance of User-Space File Systems》</a>和<a href="https://www.fsl.cs.sunysb.edu/docs/fuse/fuse-tos19-a15-vangoor.pdf" target="_blank" rel="noopener">《Performance and Resource Utilization of FUSE User-Space File Systems》</a>，是同一拨人写的，重叠度也比较高，前者发表于2017年后者发表于2019年，本文大部分内容翻译于后者。能力有限，难免有不准确或者错误的地方，欢迎指正。</p><a id="more"></a><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>传统上文件系统是作为操作系统内核一部分进行实现的，为开发者提供工具和基础设施。 随着文件系统复杂性的增加, 许多新的文件系统开始在用户空间中开发。用户空间文件系统的主要缺点是性能差, 但没人对用户空间文件系统的性能进行深入探讨。 因此, 用户空间文件系统目前仍然存在相当大的争议: 而有些人认为用户空间文件系统只是一个不能用于生产环境的“玩具”, 另一些人在用户空间中开发了成熟的、用于生产环境的文件系统。本文分析了Linux FUSE的设计和实现框架。本文在各种工作负载下分析了它的性能和资源占用。展示了2种硬件配置45种负载下FUSE的性能和资源占用情况，做了统计和追踪，帮助我们分析FUSE的性能瓶颈和说明分析结果。实验表明，在不同负载和硬件环境中，FUSE的吞吐（throughput）即使在优化后也会下降83%之多，延迟（latencies）和Ext4比会增加4倍。资源占用方面，FUSE的CPU占用相对增加31%，带宽利用率和Ext4比下降80%，不过许多数据密集型任务的负载冲撞很难统计。结论是用户空间文件系统确实可以用到生产环境（不是“玩具”），但是也要根据场景而定。</p><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>文件系统或许是最古老的、最通用的数据接口之一。虽然在微内核的年代文件系统是在用户空间实现的，大多数文件系统都是宏内核的一部分。文件系统的内核实现避免了内核和用户空间守护进程（FUSE daemon）之前消息传递的高昂开销。<br>慢慢的，用户空间文件系统又回到了今天的存储系统中。近些年来，用户空间文件系统又开始流行，下面这些标识可以说明：</p><ol><li>一些用户空间的可堆叠的（stackable）文件系统在现有文件系统上添加了专用功能开始流行（例如：去重和压缩文件系统）。</li><li>在学术界和前沿的研发环境，使用FUSE等用户空间文件系统做实验和原型已经是事实标准。</li><li>一些现存的内核层文件系统被移植到用户空间，例如 ZFS 和 NTFS。</li><li>许多公司依赖用户空间文件系统的实现，例如 IBM 的 GPFS，Nimble Storage 的 CASL，Apache 的 HDFS ，GFS，RedHat 的 GlusterFS 和 Data Domain 的 DDFS等等。一些使用云存储的文件系统，比如Google Drive、Amazon S3和DropBox。</li></ol><p>虽然用户空间文件系统还没有完全的脱离于内核文件系统，而且现在下结论也为时过早，但用户空间文件系统毫无疑问的拥有不错的发展前景。<br>用户在存储问题上有着源源不断的需求（快照、去重、加密、自动分层、副本等等）。为了支持这些需求，新产品越来越复杂。例如Btrfs 代码量超过了85000行，至少是Ext3（15000行）的5倍。当今的分布式文件系统，尤其是支持跨平台的，代码行数可以多达百万（例如：IBM的GPFS）。随着SDS（Software Defined Storage）的出现，可以预见存储软件的代码量和复杂度只会增加。<br>由于文件系统越来越复杂，用户空间文件系统也越来越受欢迎。用户空间是对开发和维护很友好的环境。NetBSD的rump kernel是第一个驱动可以运行在用户空间的“anykernel”概念的实现，当然也包含文件系统。一些编写用户空间文件系统的框架已经出现。我们现在讨论一下当下用户空间文件系统越来越流行的原因：</p><ol><li>易于开发：现在有很多的开发者工具用来跟踪、调试应用程序。用户层的bug也不会导致系统崩溃，也可以产生core文件帮助分析问题。有大量的库可以用在用户空间，也可以用更多的高级语言，不像系统侧的开发只能用C等少数语言。</li><li>便携性：有些文件系统需要运行在不同的平台上，这一点上在用户空间开发要比在内核空间开发容易的多。像分布式文件系统的客户端经常运行在不同的操作系统上。如果文件系统是在用户空间开发的，那么Unix的文件系统就可以在Windows下访问了。</li><li>丰富的软件库：用户空间有大量的库可以用来尝试新的或者改良的算法来改进文件系统的性能。例如，可以用AI算法来做预读；或者可以用分类算法来做缓存的管理。</li><li>现存的代码和用户基础：有更多的开发者在用户空间做开发，而且和内核的开发比准入门槛也低一些。</li></ol><p>当然，在用户空间能做的事在内核空间也能做。当时为了保证扩展性和控制复杂度，许多公司更愿意在用户空间开发文件系统。但是目前用户文件系统地位不断提高，也导致了支持者和反对者的更激烈的讨论。一些人认为用户空间的文件系统就是一个玩具，另外一些人把它用于生产环境。那篇名为“Linus Torvalds doesn’t understand user-space filesystems”就是争论的迹象之一。<br>辩论主要围绕两个权衡因素：（1）用户空间实现带来的性能开销有多大;（2）用户空间开发有多容易。易于开发是非常主观的，难以形式化并因此进行评估；但性能更容易根据经验进行评估。奇怪的是，关于用户空间文件系统框架的性能几乎没有人去进行研究。<br>文本中我们使用 FUSE，并探究其性能。我们基于以下4个原因首先讨论 FUSE 的设计和实现：</p><ol><li>FUSE 信息在网络上很少</li><li>FUSE 的源码中有很多复杂的异步调用和用户内核通信，很难分析；</li><li>由于 FUSE 的受欢迎程度，FUSE 的实现细节分析很有价值;</li><li>对于本文的分析，FUSE的设计是至关重要的。</li></ol><p>我们用 FUSE 在Ext4基础上开发了一个简单的代理文件系统，叫StackFS。因为复杂的文件系统需要更高的灵活性，所以我们选用 FUSE 的low-level API开发StackFS。这也避免了high-level API的性能消耗。我们通过和Ext4对比来分析StackFS的性能，我们用不同的负载在不同的硬件上测试。另外，我们测量因为FUSE导致的CPU使用率增加量。我们发现，FUSE 的性能取决于工作负载和硬件，某些情况下 FUSE 性能与 EXT4接近，但在最坏的情况下 FUSE 的可能会比 EXT4 慢3倍。<br>我们为 FUSE 设计并构建了一个丰富的测试系统来收集详细的性能指标。这些统计数据适用于任何基于FUSE的系统。我们开源了代码， <a href="http://www.filesystems.org/fuse" target="_blank" rel="noopener">http://www.filesystems.org/fuse</a> :</p><ol><li>FUSE Kernel Instrumentation: <a href="https://github.com/sbu-fsl/fuse-kernel-instrumentation.git" target="_blank" rel="noopener">https://github.com/sbu-fsl/fuse-kernel-instrumentation.git</a></li><li>FUSE Library Instrumentation: <a href="https://github.com/sbu-fsl/fuse-library-instrumentation.git" target="_blank" rel="noopener">https://github.com/sbu-fsl/fuse-library-instrumentation.git</a></li><li>Workloads, Results, and Stackable File system implementation: <a href="https://github.com/sbu-fsl/fuse-stackfs.git" target="_blank" rel="noopener">https://github.com/sbu-fsl/fuse-stackfs.git</a></li></ol><p>可以通过 <a href="http://www.filesystems.org/fuse/" target="_blank" rel="noopener">http://www.filesystems.org/fuse/</a> 获取上述代码的额外信息。我们使用这个测试系统来识别 FUSE 的性能瓶颈，并解释为什么有些场景FUSE的性能不佳，例如，我们现在可以解释，因为FUSE不能预读和合并（compound）小块的随机读从而导致其在小块读时性能不佳。<br>本文其余的部分如下：第二章讨论FUSE的架构和实现细节。第三章讨论我们的可堆叠的文件系统的实现，和一些我们加在FUSE中的插桩。第四章介绍我们的方法论。第五章主要是测试很分析结果。第六章介绍一些相关工作。第七章列举了我们之后可能会做的事情。<a href="https://www.fsl.cs.stonybrook.edu/docs/fuse/fuse-article-appendices.html" target="_blank" rel="noopener">附录</a>中记录了一些详细的参数和FUSE的API说明。</p><h1 id="二、FUSE设计"><a href="#二、FUSE设计" class="headerlink" title="二、FUSE设计"></a>二、FUSE设计</h1><p>FUSE(Filesystem in Userspace)是使用最广的用户空间文件系统框架。FUSE从基于Linux的操作系统上诞生到现在支持很多其他的操作系统。保守估计目前至少有100多个基于 FUSE 的文件系统可以在 Internet 上被找到。虽然仍然有其他用户空间文件系统框架，我们仍然选择了最受欢迎的 FUSE。<br>虽然很多人因为 FUSE 提供的简单易用的 API 选择了 FUSE 来实现文件系统，但是几乎没人讨论 FUSE 的内部架构、实现和性能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在研究FUSE（User-Space File Systems），网上相关的资料大多比较浅显。有两篇不错的论文：&lt;a href=&quot;https://libfuse.github.io/doxygen/fast17-vangoor.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《To FUSE or Not to FUSE: Performance of User-Space File Systems》&lt;/a&gt;和&lt;a href=&quot;https://www.fsl.cs.sunysb.edu/docs/fuse/fuse-tos19-a15-vangoor.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Performance and Resource Utilization of FUSE User-Space File Systems》&lt;/a&gt;，是同一拨人写的，重叠度也比较高，前者发表于2017年后者发表于2019年，本文大部分内容翻译于后者。能力有限，难免有不准确或者错误的地方，欢迎指正。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="linux fuse" scheme="http://hanyunqi.me/public/tags/linux-fuse/"/>
    
  </entry>
  
  <entry>
    <title>学习方法——费曼技巧</title>
    <link href="http://hanyunqi.me/2020/01/31/%E8%B4%B9%E6%9B%BC%E6%8A%80%E5%B7%A7/"/>
    <id>http://hanyunqi.me/2020/01/31/%E8%B4%B9%E6%9B%BC%E6%8A%80%E5%B7%A7/</id>
    <published>2020-01-31T05:31:38.000Z</published>
    <updated>2020-02-26T13:55:27.746Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://fs.blog/2012/04/feynman-technique/" target="_blank" rel="noopener">费曼技巧</a>是一种简单有效的学习方法，简单来说就是<strong>假装把你要学习的概念教授给别人，如果不能讲清楚就重新学习。</strong>它有四个步骤：</p><ol><li>选择一个你要学习的概念</li><li>假装要把它教给别人</li><li>如果发有解释不清的地方，就重新学习</li><li>尝试简化你的教授过程</li></ol><a id="more"></a><h1 id="两种知识"><a href="#两种知识" class="headerlink" title="两种知识"></a>两种知识</h1><p>有<a href="https://fs.blog/2015/01/richard-feynman-knowing-something/" target="_blank" rel="noopener">两种知识</a>，一种是知其名，另一种是知其意。如果“只知其名不知其意”是不可能给别人讲述清楚的。</p><p><em>说他知道自己的想法但却无法表达的人, 通常并不知道他自己的想法。 – Mortimer Adler</em></p><h1 id="费曼技巧"><a href="#费曼技巧" class="headerlink" title="费曼技巧"></a>费曼技巧</h1><h2 id="第一步：把它教给孩子"><a href="#第一步：把它教给孩子" class="headerlink" title="第一步：把它教给孩子"></a>第一步：把它教给孩子</h2><p>取出一张白纸，在顶部写下你想要学习的主题(subject)。写出你对这个主题的理解，就像你正在把它教给孩子一样。注意你的受教对象，不是那些聪明的成年人，而是一个8岁的孩子，他有足够的词汇和注意力来理解这些基本概念和概念间的关系。</p><p>许多人倾向于使用复杂的词汇和行话来掩盖他们并不理解的东西。但我们只是在欺骗自己，因为我们不知道自己不理解。此外，使用行话也掩盖了我们周围人的误解。</p><p>当你使用简单的话语从头到尾写出一个孩子可以理解的想法，你会强迫自己在更深的层次上理解这个概念，并简化想法之间的联系。如果你讲述不清，你便清楚知道了你距离理解它还存在的差距(gaps)，这是件好事，它预示着学习的机会。</p><h2 id="第二步：Review"><a href="#第二步：Review" class="headerlink" title="第二步：Review"></a>第二步：Review</h2><p>在第一步中，你难免会遇到讲述不清的地方，你可能是因为忘记了或者是因为没有深刻理解某些概念。</p><p>这些都是非常宝贵的反馈，因为你已经发现了你需要再学习的地方。这时候你需要重新学习，直到你可以清晰的阐述它。</p><p>提前知道哪里掌握的不好也可以让你在运用知识时少犯错误。</p><h2 id="第三步：组织和简化"><a href="#第三步：组织和简化" class="headerlink" title="第三步：组织和简化"></a>第三步：组织和简化</h2><p>现在你已经一份刚写好的笔记，重新组织、简化它。</p><p>大声读出来。如果解释得不够简单或者听起来仍然令人困惑，这说明你需要再接再厉。</p><h2 id="第四步（可选）：传递它"><a href="#第四步（可选）：传递它" class="headerlink" title="第四步（可选）：传递它"></a>第四步（可选）：传递它</h2><p>如果你真的想确定自己是否理解，那就跑去把它教给某个人（理想情况下，谁对这个主题知之甚少，谁就是理想听众，或者找个8岁的孩子！）。对你的知识的最终考验是你将它传达给其他人的能力。</p><h1 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h1><ul><li>学习的精髓不是“要知道”（只知其名）而是“要理解”（知其意）。</li><li>如果说不清就是没有深刻的理解，越能简单的阐述理解的也就越深刻。</li><li>那么面试、评审、分享等也是这个道理，如果能通俗易懂的表述，就说明有足够深刻的理解。</li><li>写博客是一个很好的学习过程。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://fs.blog/2012/04/feynman-technique/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;费曼技巧&lt;/a&gt;是一种简单有效的学习方法，简单来说就是&lt;strong&gt;假装把你要学习的概念教授给别人，如果不能讲清楚就重新学习。&lt;/strong&gt;它有四个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;选择一个你要学习的概念&lt;/li&gt;
&lt;li&gt;假装要把它教给别人&lt;/li&gt;
&lt;li&gt;如果发有解释不清的地方，就重新学习&lt;/li&gt;
&lt;li&gt;尝试简化你的教授过程&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="方法论" scheme="http://hanyunqi.me/public/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>记一次计算密集型服务的性能优化</title>
    <link href="http://hanyunqi.me/2020/01/13/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%AE%A1%E7%AE%97%E5%AF%86%E9%9B%86%E5%9E%8B%E6%9C%8D%E5%8A%A1%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://hanyunqi.me/2020/01/13/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%AE%A1%E7%AE%97%E5%AF%86%E9%9B%86%E5%9E%8B%E6%9C%8D%E5%8A%A1%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</id>
    <published>2020-01-13T09:47:30.000Z</published>
    <updated>2020-02-26T13:55:55.770Z</updated>
    
    <content type="html"><![CDATA[<p>性能优化是一个庞杂的话题，不同的场景，不同的视角都会得到不同的理解。<br>比如：有的为了提高吞吐，有的为了降低延迟，有的为了节省资源。<br>他们并不是同一个问题，有时可以牺牲一定的延迟来换取更高的吞吐，比如批量处理；<br>有时可以用更多的存储空间来换取更低的延迟，比如哈希表……</p><p>本文讲述的是对计算密集型服务提高吞吐和降低延迟的优化经验和理解。</p><a id="more"></a><h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>这是微服务框架下的一个末端计算节点，使用C++编写，只有一个上游调用方，没有下游。<br>不使用数据库等外部存储，所有数据都在内存中（约占用45GB内存）。<br>使用Thrift ThreadPool框架，接收到请求后，根据内存中的数据做“简单”计算后打成ProtoBuffer包返回给调用方。</p><p><strong>在48核物理机上，优化前极限QPS是3.5k左右，优化后的极限QPS超过14k，性能提升4倍。</strong></p><h1 id="二、方法论"><a href="#二、方法论" class="headerlink" title="二、方法论"></a>二、方法论</h1><p>性能优化也可以从不同层面去考虑，比如业务流程、架构设计、硬件配置亦或是代码编写等。<br>本文主要从代码优化的角度来优化性能。</p><p>使用perf等工具可以分析出热点代码。<br><strong>根据二八法则，优化20%的代码可以提升80%的性能。</strong><br>所以要先找出瓶颈，然后优化这个瓶颈，然后再找下一个瓶颈……</p><img src="/images/2020/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%84%91%E5%9B%BE.png" class="[class name]"><p>如上图，我归纳了一些常见的性能瓶颈。<br>一般极限QPS下如果CPU利用率不高，就要考虑是否有阻塞或者竞争（锁）；<br>如果CPU利用率达到或者接近100%，极限性能还是不高，可以考虑优化流程，算法，去除不必要的内存拷贝，减少堆内存的申请、释放和系统调用等。</p><p>当然，有些系统看上去没有明显的瓶颈（没有明显的热点代码），这时候就比较考验工程师对性能优化的理解了。<br>一般可以从精简流程或者使用高效的“方法”替代低效的“方法”入手。<br>比如减少临时对象，使用哈希表替代红黑树，提高缓存利用率等方法。</p><img src="/images/2020/linux_kernal_architecture.png" class="[class name]"><p><strong>做好性能优化的关键是：了解计算机是如何运转的。</strong></p><ol><li>了解硬件的工作原理，知道哪些操作快哪些些操作慢，比如：相比于内存，磁盘IO的速度比较慢；相比于cache，内存的读写比较慢等等。</li><li>在硬件之上要了解操作系统的工作原理，比如：堆内存和栈内存的区别，系统调用和函数调用的区别，锁的实现原理等等。</li><li>在操作系统之上要了解编译器和标准库都做了什么。执行一行看似简单的代码计算机要做哪些操作?</li><li>再之上就是对算法和业务的理解了。很多时候低效的算法和冗余的业务逻辑才是拖累系统性能的关键。</li></ol><p><strong>性能优化是一个系统工程，不能一味的追求性能，除了如何优化还要考虑其他问题：</strong></p><ol><li>是否需要优化？过早的优化是万恶之源。</li><li>投入产出比</li><li>稳定性，因改造引入的风险</li><li>鲁棒性</li><li>代码的可读性</li><li>维护成本</li><li>可扩展性</li></ol><h1 id="三、第一轮优化——去除IO阻塞"><a href="#三、第一轮优化——去除IO阻塞" class="headerlink" title="三、第一轮优化——去除IO阻塞"></a>三、第一轮优化——去除IO阻塞</h1><p><strong>找到瓶颈，依据数据而不是凭空猜测。</strong></p><p>优化前的极限QPS是3.5k，简单分析一下发现总的CPU利用率只有50%左右，推断系统内部有严重的阻塞（条件等待）。<br>常见阻塞原因有IO阻塞和互斥锁，使用<a href="https://linux.die.net/man/1/iostat" target="_blank" rel="noopener">iostat</a>进一步观察系统状态发现await和iowait都很高，这说明IO阻塞比较严重。<br>因为系统运行时只有写日志会触发IO，所以怀疑是写同步日志造成的IO阻塞。<br>关闭日志后压测发现极限QPS可以达到8k+，这基本可以断定写同步日志对系统性能影响比较大。<br>将同步日志改为异步日志很容易，可是也会带来一些弊端。<br>最严重的就是有丢日志的风险，进程异常退出时可能导致缓存中的日志不能刷到磁盘上。<br>考虑到日志本身价值不大，只有在系统异常退出时（比如OOM），需要日志辅助定位问题。<br>综合考虑后，打算把错误日志记同步日志，其他的记异步日志。<br>这次优化的收益很明显，只修改了日志配置，极限QPS从3.5k提升到7k+。<br>后续打算把访问日志分离出来，也记同步日志，降低丢日志的影响。</p><h1 id="四、第二轮优化——代码优化"><a href="#四、第二轮优化——代码优化" class="headerlink" title="四、第二轮优化——代码优化"></a>四、第二轮优化——代码优化</h1><p><strong>二八法则，优先解决头部问题。</strong></p><img src="/images/2020/ng_191209_rel.svg" class="[class name]"><p>火焰图</p><p>从火焰图上看到除了malloc和free没有明显的热点代码。<br>压到极限QPS时，总的CPU利用率也只有70%。<br>分析一下malloc的过程，不难发现其内部是有线程锁的。<br>IO阻塞解决后，malloc的阻塞问题就凸显出来了。<br>TCMalloc做了线程级的缓存，理论上可以缓解锁竞争的问题。<br>可是换用TCMalloc后发现性能并没有提升（后来证明是因为未正确编译导致的，这里走了一些弯路），然后就尝试了其他思路，从代码的层面入手。</p><p><strong>要了解计算机是如何运行的，知道每行代码都做了什么。</strong></p><h2 id="4-1-去除冗余逻辑"><a href="#4-1-去除冗余逻辑" class="headerlink" title="4.1 去除冗余逻辑"></a>4.1 去除冗余逻辑</h2><p>由于历史原因，代码中有一些中间数据结构，数据结构间的转换带来了额外的性能开销。<br>还有一些为记录调试日志的额外操作，比如吧PB序列化成文本或者字符串拼接等。<br>再有就是去除不必要的拷贝和临时变量。</p><h2 id="4-2-标准模板-STL-的性能优化"><a href="#4-2-标准模板-STL-的性能优化" class="headerlink" title="4.2 标准模板(STL)的性能优化"></a>4.2 标准模板(STL)的性能优化</h2><p>在代码中没有搜索到太多的malloc/free和new/delete，这和火焰图显示的结果不符。</p><p>进一步翻阅代码发现有大量的STL容器（vector、string等）的使用，虽然这些都是在栈上创建的对象，但是他们都会申请堆上的内存。这些容器在增长的时候都可能会重新申请内存，比如vector的push_back()就会因为剩余容量不足导致重新申请内存，而且还可能要触发拷贝。<br>字符串（string）拼接的时候也有类似的问题。<br>这种问题可以同reserve来解决，前提是能预估最大容量。</p><p>另外vector的push_back()会多触发一次拷贝，所以用emplace_back()性能会更好一些。</p><p>针对调用频繁，size不大的且可以确定的vector，用完全在栈上的对象（我用STL风格的API封装的“数组”）代替。<br>栈内存的申请几乎不消耗时间，只需要移动栈顶指针即可，内存连续，cache利用率也高;<br>而堆内存的申请就比较复杂，可能涉及到线程间的竞争，即使有线程级缓存，也难免会带来额外的计算开销。</p><p>iostream用起来很方便，但是性能很糟糕，调用频繁的地方可以用snprintf()代替。</p><p>如果可以的话，用unordered_map代替map，用数组代替unordered_map。</p><h1 id="五、第三轮优化——减少竞争"><a href="#五、第三轮优化——减少竞争" class="headerlink" title="五、第三轮优化——减少竞争"></a>五、第三轮优化——减少竞争</h1><p>做完第二轮优化，性能提升50%，极限QPS从7k提升到10k+。<br>这时候malloc/free带来的开销就更加突出，而且极限情况下CPU利用率也只有70%。<br>所以锁推断是因为malloc/free中有线程锁，加上STL频繁的申请释放内存导致的。<br>因为TCMalloc有线程级的缓存，可以缓解这一现象，这和第二轮优化中的测试结果不符（因为编译问题导致TCMalloc未能生效）。<br>仔细检查并修正后，性能大幅提升，极限QPS可以超过14k。CPU利用率达到95%左右。</p><img src="/images/2020/perf.ng.%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%90%8E.svg" class="[class name]"><p>优化后的火焰图</p><h1 id="六、还可以做哪些优化"><a href="#六、还可以做哪些优化" class="headerlink" title="六、还可以做哪些优化"></a>六、还可以做哪些优化</h1><p>前三轮优化使性能提升4倍，总体改动量不大，风险也可控，所以产出投入比还是很高的。<br>还有一些可以优化的点，因为改造成本、改造风险、运维成本和收益不够等原因暂时没有实施。</p><h2 id="6-1-优化数据结构"><a href="#6-1-优化数据结构" class="headerlink" title="6.1 优化数据结构"></a>6.1 优化数据结构</h2><p>服务会用到大量的静态数据，单份数据超过20GB。这些数据的结构还有优化空间。</p><ol><li>有些数据用二叉树做索引，如果换成哈希表性能会更好。</li><li>数据不够紧凑，还有压缩空间，一般数据越紧凑对cache的利用率也会越高。</li></ol><h2 id="6-2-优化ProtoBuffer"><a href="#6-2-优化ProtoBuffer" class="headerlink" title="6.2 优化ProtoBuffer"></a>6.2 优化ProtoBuffer</h2><p>ProtoBuffer也会因为频繁的申请/释放小对象导致性能不佳，可以用<a href="https://developers.google.com/protocol-buffers/docs/reference/arenas" target="_blank" rel="noopener">Arena Allocation</a>优化。</p><p>Memory allocation and deallocation constitutes a significant fraction of CPU time spent in protocol buffers code. By default, protocol buffers performs heap allocations for each message object, each of its subobjects, and several field types, such as strings. These allocations occur in bulk when parsing a message and when building new messages in memory, and associated deallocations happen when messages and their subobject trees are freed.</p><h2 id="6-3-使用Huge-Page"><a href="#6-3-使用Huge-Page" class="headerlink" title="6.3 使用Huge Page"></a>6.3 使用Huge Page</h2><p><a href="https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt" target="_blank" rel="noopener">Huge Page</a>，是指的大页内存管理方式。与传统的4KB的普通页管理方式相比，Huge Page管理大内存(8GB以上)更为高效。<br>我们的服务占用40GB以上的内存，所以理论上使用Huge Page会有一定性能提升。<br>不过使用Huge Page也会带来额外的运维成本，也需要综合考虑风险和稳定性等原因。</p><img src="/images/2020/huge_page.jpg" class="[class name]"><p>Huge Page的示意图</p><h1 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h1><h2 id="7-1-是否需要优化？"><a href="#7-1-是否需要优化？" class="headerlink" title="7.1 是否需要优化？"></a>7.1 是否需要优化？</h2><p>性能优化是一个复杂的问题，除了如何提高性能还需要从收益、成本、风险等维度综合考虑。<br>尤其要考虑清楚为什么要优化？是否需要优化？产出投入比是否够高？是否有更好的解决方案?</p><h2 id="7-2-“上兵伐谋”"><a href="#7-2-“上兵伐谋”" class="headerlink" title="7.2 “上兵伐谋”"></a>7.2 “上兵伐谋”</h2><p>不能上来就扎到代码里，“宏观”上的优化可能会有奇效。</p><ol><li>流程：业务流程是否可以优化？有时删掉一个冗余的逻辑会有大幅的收益。</li><li>算法：在规模较大时，时间复杂度上的差异往往是致命的。</li><li>机制：同步OR异步，通知OR轮询，阻塞OR非阻塞等等。机制上的差异是很难弥补的。</li><li>取舍：时间和空间互换，吞吐和延迟互换，做出合适的取舍，可以事半功倍。</li></ol><h2 id="7-3-“其下攻城”"><a href="#7-3-“其下攻城”" class="headerlink" title="7.3 “其下攻城”"></a>7.3 “其下攻城”</h2><p>代码是给人看的，程序还要靠计算机来运行。要知道计算机是如何运行的，知道每行代码背后计算机都做了什么，知道哪些操作快、哪些操作慢，才能做好性能优化。</p><img src="/images/2020/linux_performance_tools.jpeg" class="[class name]"><p>有太多的点不能一一列举，总结一下就是：<strong>理论指导实践，实践检验理论。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;性能优化是一个庞杂的话题，不同的场景，不同的视角都会得到不同的理解。&lt;br&gt;比如：有的为了提高吞吐，有的为了降低延迟，有的为了节省资源。&lt;br&gt;他们并不是同一个问题，有时可以牺牲一定的延迟来换取更高的吞吐，比如批量处理；&lt;br&gt;有时可以用更多的存储空间来换取更低的延迟，比如哈希表……&lt;/p&gt;
&lt;p&gt;本文讲述的是对计算密集型服务提高吞吐和降低延迟的优化经验和理解。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="c++ linux" scheme="http://hanyunqi.me/public/tags/c-linux/"/>
    
  </entry>
  
  <entry>
    <title>RCU(Read Copy Update)</title>
    <link href="http://hanyunqi.me/2019/05/27/rcu/"/>
    <id>http://hanyunqi.me/2019/05/27/rcu/</id>
    <published>2019-05-27T08:52:47.000Z</published>
    <updated>2019-05-28T06:33:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间做系统重构，需要一个快速的本地缓存，类似于黑名单，读多写少的那种。<br>之前一直用的是哈希表加读写锁的方案，如果出现大规模的写操作，会导致读操作被阻塞。<br>想找一个更高效的解决方案，最好是无锁。<br><a id="more"></a></p><h1 id="Linux-kernel中的RCU"><a href="#Linux-kernel中的RCU" class="headerlink" title="Linux kernel中的RCU"></a>Linux kernel中的RCU</h1><p>以前听说过Radix Tree，Linux用它来管理路由表，和我面临的场景有些类似，相信Linux选用的肯定是高效的。所以打算研究一下，找一些启发。<br>研究时发现使用的是Radix Tree + RCU来解决的。感觉推开了新世界的大门。</p><p>以链表为例，通过无锁操作可以无锁的更新链表，如图：</p><ol><li><p>初始链表</p><img src="/images/rcu/MultiVersion1.jpg" class="[class name]"></li><li><p>申请新节点内存</p><img src="/images/rcu/MultiVersion2.jpg" class="[class name]"></li><li><p>复制要更新的节点</p><img src="/images/rcu/MultiVersion3.jpg" class="[class name]"></li><li><p>修改next指针</p><img src="/images/rcu/MultiVersion4.jpg" class="[class name]"></li><li><p>修改新节点中的内容</p><img src="/images/rcu/MultiVersion5.jpg" class="[class name]"></li><li><p>将其插入链表</p><img src="/images/rcu/MultiVersion6.jpg" class="[class name]"></li></ol><p>以上所有操作都不需要加锁，但是有一个问题，何时可以释放p指向的节点？因为不确定是否还有其他“线程”在读这块内存。<br>这好像是一个内存回收的问题，在带有GC的语音中，这似乎不是问题，但是c/c++中不行。</p><p>利用一些内存回收技术可以解决这一问题，比如智能指针或者QSBR(Quiescent State-Based Reclamation)。</p><h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><p>智能指针是一个简单易行的方案，但是智能指针的赋值不是原子的，需要对其加锁。</p><h1 id="QSBR"><a href="#QSBR" class="headerlink" title="QSBR"></a>QSBR</h1><p>QSBR的核心思想就是识别出线程的不活动(quiescent)状态，那么什么时候才算是不活动的状态呢？这个状态和临界区状态是相对的，线程离开临界区就是不活动的状态了。</p><img src="/images/rcu/rcu_qsbr.png" class="[class name]"><p>简单的说就是每个读线程在离开临界区时记录一下自己的状态，写线程检查这个状态，当所有线程都离开临界区时就可以释放旧节点了。</p><h1 id="在服务中使用RCU-QSBR"><a href="#在服务中使用RCU-QSBR" class="headerlink" title="在服务中使用RCU-QSBR"></a>在服务中使用RCU-QSBR</h1><p>幸好有<a href="https://github.com/urcu/userspace-rcu" target="_blank" rel="external">urcu</a>这个开源实现。如前文所说，数据可以通过copy的方式进行原子更新，难点在于合适释放被替换的节点。利用RCU-QSBR我们可以在服务线程返回请求时标记自己退出临界区。这样做虽然扩大了临界区的范围，但是对应用层是透明的，应用层的开发者感知不到RCU的存在。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间做系统重构，需要一个快速的本地缓存，类似于黑名单，读多写少的那种。&lt;br&gt;之前一直用的是哈希表加读写锁的方案，如果出现大规模的写操作，会导致读操作被阻塞。&lt;br&gt;想找一个更高效的解决方案，最好是无锁。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="c++" scheme="http://hanyunqi.me/public/tags/c/"/>
    
      <category term="linux" scheme="http://hanyunqi.me/public/tags/linux/"/>
    
      <category term="lock-free" scheme="http://hanyunqi.me/public/tags/lock-free/"/>
    
  </entry>
  
  <entry>
    <title>多读场景下的本地缓存</title>
    <link href="http://hanyunqi.me/2019/04/25/rcu-cache/"/>
    <id>http://hanyunqi.me/2019/04/25/rcu-cache/</id>
    <published>2019-04-25T02:10:47.000Z</published>
    <updated>2019-05-30T03:01:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>在读写分离的架构中通常需要一个高性能的缓存，而且这个缓存是读多写少的。<br>比如黑名单缓存，一个线程负责更新，多个线程读取。<br><a id="more"></a></p><h1 id="哈希表-读写锁"><a href="#哈希表-读写锁" class="headerlink" title="哈希表 + 读写锁"></a>哈希表 + 读写锁</h1><p>这是一个简单通用的方案，一般对性能要求不高时可以使用。虽然简单，缺点也很明显，写时会阻塞读。</p><h1 id="Concurrent-Hash-Map"><a href="#Concurrent-Hash-Map" class="headerlink" title="Concurrent Hash Map"></a>Concurrent Hash Map</h1><p>支持多线程的哈希表有很多种实现方式，Java中的ConcurrentHashMap是一个不错的实现，但其本质也是分段加锁，虽然降低了竞争锁的概率，但是也不能避免。</p><p>多线程下，哈希表的rehash是一个难题，大多实现都很难避免加锁，而且C++也没有相应的标准。</p><h1 id="双Buffer"><a href="#双Buffer" class="headerlink" title="双Buffer"></a>双Buffer</h1><p>双Buffer也是一个常用的手段。一般有两种：一种是两块固定的不会被回收的Buffer，两个Buffer交替使用，这样做可以避免Buffer的内存回收，但是需要管理两个buffer的交替时机，这是一个难题。很多时候是靠“超时”来保证的，比如双buffer的交替频率是10秒，而buffer的一次访问时间不会超过100毫秒等。这种方式虽然hack，但大部分场景下是有效的。</p><h1 id="COW-智能指针-自旋锁-spin-lock"><a href="#COW-智能指针-自旋锁-spin-lock" class="headerlink" title="COW + 智能指针 + 自旋锁(spin lock)"></a>COW + 智能指针 + 自旋锁(spin lock)</h1><p>用智能指针管理内存是个不错的方式，但是也有弊端。<br>智能指针的赋值不是原子的，所以多线程情况下其赋值时需要加锁（C++11中有智能指针的原子操作），为了保证效率可以选用spin lock。<br>除了需要加锁还有另外一个问题：“不能确定内存的释放时机”，智能指针是在引用计数归零时释放内存的，考虑到业务系统复杂多变，而且在多线程情况会变得更复杂。如果在处理业务的线程释放，可能会影响其响应时间。而且如果更新的频率过高而且旧的内存迟迟不能释放，会导致过多的内存副本，严重时会导致OOM。</p><h1 id="RCU-Read-Copy-Update-QSBR"><a href="#RCU-Read-Copy-Update-QSBR" class="headerlink" title="RCU(Read Copy Update) + QSBR"></a>RCU(Read Copy Update) + QSBR</h1><p>RCU并不是新技术其理论早有人提出，Linux内核中也有大量的使用。<br>利用RCU可以做到读时无锁。不同于用智能指针管理内存，利用RCU和QSBR可以优雅的回收内存。写线程可以知道读线程何时结束读，确保及时、安全的回收内存。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在读写分离的架构中通常需要一个高性能的缓存，而且这个缓存是读多写少的。&lt;br&gt;比如黑名单缓存，一个线程负责更新，多个线程读取。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="c++" scheme="http://hanyunqi.me/public/tags/c/"/>
    
      <category term="rcu" scheme="http://hanyunqi.me/public/tags/rcu/"/>
    
  </entry>
  
  <entry>
    <title>有趣的代码</title>
    <link href="http://hanyunqi.me/2018/05/03/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BB%A3%E7%A0%81/"/>
    <id>http://hanyunqi.me/2018/05/03/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BB%A3%E7%A0%81/</id>
    <published>2018-05-03T09:42:16.000Z</published>
    <updated>2019-05-28T03:31:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天刷论坛时发现下面这段代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">i = <span class="number">0x5f3759df</span> - ( i &gt;&gt; <span class="number">1</span> );               <span class="comment">// what the fuck?</span></div></pre></td></tr></table></figure></p><p>哈哈，刚看到这行时我也不禁说了一句：“what the fuck?”<br><a id="more"></a></p><p>完整的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">** float q_rsqrt( float number )</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">float</span> <span class="title">Q_rsqrt</span><span class="params">( <span class="keyword">float</span> number )</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">long</span> i;</div><div class="line">    <span class="keyword">float</span> x2, y;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">float</span> threehalfs = <span class="number">1.5F</span>;</div><div class="line"></div><div class="line">    x2 = number * <span class="number">0.5F</span>;</div><div class="line">    y  = number;</div><div class="line">    i  = * ( <span class="keyword">long</span> * ) &amp;y;                       <span class="comment">// evil floating point bit level hacking</span></div><div class="line">    i  = <span class="number">0x5f3759df</span> - ( i &gt;&gt; <span class="number">1</span> );               <span class="comment">// what the fuck?</span></div><div class="line">    y  = * ( <span class="keyword">float</span> * ) &amp;i;</div><div class="line">    y  = y * ( threehalfs - ( x2 * y * y ) );   <span class="comment">// 1st iteration</span></div><div class="line"><span class="comment">//  y  = y * ( threehalfs - ( x2 * y * y ) );   // 2nd iteration, this can be removed</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> Q3_VM</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __linux__</span></div><div class="line">    assert( !isnan(y) ); <span class="comment">// bk010122 - FPE?</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="keyword">return</span> y;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这是《雷神之锤III》中的代码(<a href="http://archive.wikiwix.com/cache/20110217051631/ftp://ftp.idsoftware.com/idstuff/source/quake3-1.32b-source.zip" target="_blank" rel="external">quake3-1.32b/code/game/q_math.c</a>)。是<a href="https://zh.wikipedia.org/wiki/平方根倒数速算法" target="_blank" rel="external">平方根倒数速算法</a>。把浮点数当做整数来处理，还有这种操作？（what the fuck?）不禁感叹前人的智慧。</p><p>联想到以前读Redis源码时，里面也有有趣的（diao diao的）注释。</p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">"don't play with this unless you benchmark! ... just believe me, it works"</span></div><div class="line">（不要优化这段代码，除非你做了性能测试。…… 相信我）</div></pre></td></tr></table></figure><p>完整的代码在<a href="https://github.com/antirez/redis/blob/e6b0e8d9ec4561a07864358af8d2d4e81ac413fc/src/lzf_c.c#L39" target="_blank" rel="external">这里</a>。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">#define HSIZE (1 &lt;&lt; (HLOG))</div><div class="line"></div><div class="line">/*</div><div class="line"> * don't play with this unless you benchmark!</div><div class="line"> * the data format is not dependent on the hash function.</div><div class="line"> * the hash function might seem strange, just believe me,</div><div class="line"> * it works ;)</div><div class="line"> */</div><div class="line">#ifndef FRST</div><div class="line"># define FRST(p) (((p[0]) &lt;&lt; 8) | p[1])</div><div class="line"># define NEXT(v,p) (((v) &lt;&lt; 8) | p[2])</div><div class="line"># if ULTRA_FAST</div><div class="line">#  define IDX(h) ((( h             &gt;&gt; (3*8 - HLOG)) - h  ) &amp; (HSIZE - 1))</div><div class="line"># elif VERY_FAST</div><div class="line">#  define IDX(h) ((( h             &gt;&gt; (3*8 - HLOG)) - h*5) &amp; (HSIZE - 1))</div><div class="line"># else</div><div class="line">#  define IDX(h) ((((h ^ (h &lt;&lt; 5)) &gt;&gt; (3*8 - HLOG)) - h*5) &amp; (HSIZE - 1))</div><div class="line"># endif</div><div class="line">#endif</div><div class="line">/*</div><div class="line"> * IDX works because it is very similar to a multiplicative hash, e.g.</div><div class="line"> * ((h * 57321 &gt;&gt; (3*8 - HLOG)) &amp; (HSIZE - 1))</div><div class="line"> * the latter is also quite fast on newer CPUs, and compresses similarly.</div><div class="line"> *</div><div class="line"> * the next one is also quite good, albeit slow ;)</div><div class="line"> * (int)(cos(h &amp; 0xffffff) * 1e6)</div><div class="line"> */</div></pre></td></tr></table></figure><p>短短的几行代码，堪称智慧的结晶。这也是计算机有趣的地方。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天刷论坛时发现下面这段代码&lt;br&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;i = &lt;span class=&quot;number&quot;&gt;0x5f3759df&lt;/span&gt; - ( i &amp;gt;&amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; );               &lt;span class=&quot;comment&quot;&gt;// what the fuck?&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;哈哈，刚看到这行时我也不禁说了一句：“what the fuck?”&lt;br&gt;
    
    </summary>
    
    
    
      <category term="c++" scheme="http://hanyunqi.me/public/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>用C++写一个单例</title>
    <link href="http://hanyunqi.me/2018/04/28/singleton/"/>
    <id>http://hanyunqi.me/2018/04/28/singleton/</id>
    <published>2018-04-28T07:21:10.000Z</published>
    <updated>2020-01-14T02:23:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>“请用C++写一个单例，考虑一下多线程环境。”<br>这是一个常见的面试题，别人问过我，我也问过别人。<br>这个问题可以很简单，也可以很复杂。<br><a id="more"></a></p><h1 id="简单有效的单例"><a href="#简单有效的单例" class="headerlink" title="简单有效的单例"></a>简单有效的单例</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Singleton &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        Singleton singleton;</div><div class="line">        <span class="keyword">return</span> &amp;singleton;</div><div class="line">    &#125;   </div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>在C++11中静态局部变量的初始化是线程安全的，<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2660.htm#LocalDecl" target="_blank" rel="external">参考链接</a>。<br>这种写法既简单，又是线程安全的，可以满足大多数场景的需求。</p><h1 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h1><p>单例在程序初期进行初始化。即如论如何都会初始化。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Singleton &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> singleton;</div><div class="line">    &#125;   </div><div class="line"></div><div class="line"><span class="keyword">static</span> Singleton* singleton;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Singleton* Singleton::singleton = <span class="keyword">new</span> Singleton();</div></pre></td></tr></table></figure></p><p>这种写法也是线程安全的，不过Singleton的构造函数在main函数之前执行，有些场景下是不允许这么做的。改进一下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Singleton &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> singleton;</div><div class="line">    &#125;   </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Init</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> Singleton* singleton;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Singleton* Singleton::singleton = <span class="keyword">new</span> Singleton();</div></pre></td></tr></table></figure></p><p>将复杂的初始化操作放在Init函数中，在主线程中调用。</p><h1 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h1><p>单例在首次调用时进行初始化。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Singleton &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (singleton == <span class="literal">NULL</span>) &#123;</div><div class="line">            singleton = <span class="keyword">new</span> Singleton();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> singleton;</div><div class="line">    &#125;   </div><div class="line"></div><div class="line">    <span class="keyword">static</span> Singleton* singleton;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Singleton* Singleton::singleton = <span class="literal">NULL</span>;</div></pre></td></tr></table></figure></p><p>这样写不是线程安全的。改进一下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Singleton &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        lock();</div><div class="line">        <span class="keyword">if</span> (singleton == <span class="literal">NULL</span>) &#123;</div><div class="line">            singleton = <span class="keyword">new</span> Singleton();</div><div class="line">        &#125;</div><div class="line">        unlock();</div><div class="line">        <span class="keyword">return</span> singleton;</div><div class="line">    &#125;   </div><div class="line"></div><div class="line">    <span class="keyword">static</span> Singleton* singleton;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Singleton* Singleton::singleton = <span class="literal">NULL</span>;</div></pre></td></tr></table></figure></p><p>这样写虽是线程安全的，但每次都要加锁会影响性能。</p><h1 id="DCLP（Double-Checked-Locking-Pattern）"><a href="#DCLP（Double-Checked-Locking-Pattern）" class="headerlink" title="DCLP（Double-Checked Locking Pattern）"></a>DCLP（Double-Checked Locking Pattern）</h1><p>在懒汉模式的基础上再改进一下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Singleton &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (singleton == <span class="literal">NULL</span>) &#123;</div><div class="line">            lock();</div><div class="line">            <span class="keyword">if</span> (singleton == <span class="literal">NULL</span>) &#123;</div><div class="line">                singleton = <span class="keyword">new</span> Singleton();</div><div class="line">            &#125;</div><div class="line">            unlock();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> singleton;</div><div class="line">    &#125;   </div><div class="line"></div><div class="line">    <span class="keyword">static</span> Singleton* singleton;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Singleton* Singleton::singleton = <span class="literal">NULL</span>;</div></pre></td></tr></table></figure></p><p>两次if判断避免了每次都要加锁。但是，这样仍是不安全的。因为”singleton = new Singleton();”这句不是原子的。<br>这句可以分为3步：</p><ol><li>申请内存</li><li>调用构造函数</li><li>将内存指针赋值给singleton</li></ol><p>上面这个顺序是我们期望的，可以编译器并不会保证这个执行顺序。所以也有可能是按下面这个顺序执行的：</p><ol><li>申请内存</li><li>将内存指针赋值给singleton</li><li>调用构造函数</li></ol><p>这样就会导致其他线程可能获取到未构造好的单例指针。<br>解决办法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Singleton &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (singleton == <span class="literal">NULL</span>) &#123;</div><div class="line">            lock();</div><div class="line">            <span class="keyword">if</span> (singleton == <span class="literal">NULL</span>) &#123;</div><div class="line">                Singleton* tmp = <span class="keyword">new</span> Singleton();</div><div class="line">                memory_barrier();  <span class="comment">// 内存屏障</span></div><div class="line">                singleton = tmp;</div><div class="line">            &#125;</div><div class="line">            unlock();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> singleton;</div><div class="line">    &#125;   </div><div class="line"></div><div class="line">    <span class="keyword">static</span> Singleton* singleton;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Singleton* Singleton::singleton = <span class="literal">NULL</span>;</div></pre></td></tr></table></figure></p><p>语义上，<a href="https://zh.wikipedia.org/wiki/内存屏障" target="_blank" rel="external">内存屏障</a>之前的所有写操作都要写入内存；内存屏障之后的读操作都可以获得同步屏障之前的写操作的结果。简单的说就是保证指令一定程度上的按顺序执行，避免上述所说的乱序行为。<br>把单例写成这么复杂也是醉了。</p><h1 id="返回指针还是引用？"><a href="#返回指针还是引用？" class="headerlink" title="返回指针还是引用？"></a>返回指针还是引用？</h1><p>Singleton返回的实例的生存期是由Singleton本身所决定的，而不是用户代码。我们知道，指针和引用在语法上的最大区别就是指针可以为NULL，并可以通过delete运算符删除指针所指的实例，而引用则不可以。由该语法区别引申出的语义区别之一就是这些实例的生存期意义：通过引用所返回的实例，生存期由非用户代码管理，而通过指针返回的实例，其可能在某个时间点没有被创建，或是可以被删除的。但是这两条Singleton都不满足，所以返回引用更好一些。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Singleton &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">static</span> Singleton&amp; <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">static</span> Singleton singleton;</div><div class="line">        <span class="keyword">return</span> singleton;</div><div class="line">    &#125;   </div><div class="line"></div><div class="line">    <span class="comment">// 如果需要有比较重的初始化操作，则在安全的情况下初始化</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Init</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">// 禁用构造函数、拷贝构造函数、拷贝函数</span></div><div class="line">    Singleton();</div><div class="line">    Singleton(<span class="keyword">const</span> Singleton&amp;);</div><div class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>这种写法比较简单，可以满足大多数场景的需求。如果不能满足需求，再考虑DCLP那种复杂的模式。如《UNIX编程艺术》中所说：“Keep it sample, Stupid！”</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://locklessinc.com/articles/singleton_pattern/" target="_blank" rel="external">The Singleton Pattern</a><br><a href="http://www.cnblogs.com/loveis715/archive/2012/07/18/2598409.html" target="_blank" rel="external">面试中的Singleton</a><br><a href="https://zh.wikipedia.org/wiki/内存屏障" target="_blank" rel="external">内存屏障</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;“请用C++写一个单例，考虑一下多线程环境。”&lt;br&gt;这是一个常见的面试题，别人问过我，我也问过别人。&lt;br&gt;这个问题可以很简单，也可以很复杂。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="c++" scheme="http://hanyunqi.me/public/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>静态的希尔伯特RTree</title>
    <link href="http://hanyunqi.me/2018/04/25/hilbert-rtree/"/>
    <id>http://hanyunqi.me/2018/04/25/hilbert-rtree/</id>
    <published>2018-04-25T02:10:47.000Z</published>
    <updated>2019-05-28T03:33:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>先考虑一个常见的问题：如何搜索附近的人（车、银行、餐厅等）？<br>可以把这类问题抽象成：快速搜索二维（或者高维）空间上某一指定区域内的数据。<br>很明显，简单的二叉树或者哈希表解决不了这个问题。<br><a id="more"></a></p><h1 id="一、空间索引"><a href="#一、空间索引" class="headerlink" title="一、空间索引"></a>一、空间索引</h1><p>空间索引是对二维或者多维空间坐标的索引，其本质不外乎树和哈希表两种结构。比如GeoHash就是将空间划分成若干子空间，然后再映射成唯一的编码，以哈希表的形式存储。再比如KDTree和RTree，其本质都是树，不同的是KDTree是通过分割空间的方式构建树，而RTree是通过选取空间的方式构建树。</p><h1 id="二、RTree"><a href="#二、RTree" class="headerlink" title="二、RTree"></a>二、RTree</h1><p>RTree是高度平衡的多叉树。他用最小外接矩形（minimum bounding rectangle, MBR）表示一个节点，N个子节点的最小外接矩形构成了他们的父节点，如果某一层只有一个节点，那么该节点就是根（root）节点。如下图：<br><img src="/images/R-tree.svg" class="[class name]"><br>如上图，R8、R9、R10是叶子节点，它们的最小外接矩形构成了它们的父节点R3。R3、R4、R5的最小外接矩形又构成了它们的父节点R1。<br>构建RTree的关键就是如何构建这些最小外接矩形，一般这些矩形的面积、周长越小越好。也就是说同一节点下的各子节点距离越近越好。</p><h1 id="三、希尔伯特曲线"><a href="#三、希尔伯特曲线" class="headerlink" title="三、希尔伯特曲线"></a>三、希尔伯特曲线</h1><p>希尔伯特曲线是一种填充曲线，可以线性地贯穿二维或者更高维度每个离散单元，并且仅仅穿过一次，并对每个离散单元进行线性排序和编码，该编码作为该单元的唯一标识。希尔伯特曲线可以将高维空间中的数据映射到一维空间。如下图所示：<br><img src="/images/hilbert_curve.png" class="[class name]"><br>从上图可以看出，希尔伯特编码相近的点在平面上的位置也相近。当然，这一性质在数学上是有证明的，这里不做讨论。</p><h1 id="四、希尔伯特RTree"><a href="#四、希尔伯特RTree" class="headerlink" title="四、希尔伯特RTree"></a>四、希尔伯特RTree</h1><p> 利用希尔伯特曲线的性质，可以将RTree的各子节点进行编码、排序，如此往复就可以构建一棵希尔伯特RTree。</p><h2 id="算法描述："><a href="#算法描述：" class="headerlink" title="算法描述："></a>算法描述：</h2><p>步骤一：计算每一个数据矩形中心的希尔伯特值<br>步骤二：按照希尔伯特值升序将数据矩形排序<br>步骤三：// 构造结点（层L=1）<br>        while（有更多的矩形）<br>            生成一个新的R树结点<br>            将后续C个矩形分配到这个结点上<br>步骤四：// 构造更高层（L+1）的结点<br>        L = L + 1<br>        如果L层中只有一个节点，那么该节点就是根节点，算法结束<br>        否则，把该层节点按照生成时间升序排序，重复步骤三</p><h2 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> HilbertRTree &#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt; nodes_;        <span class="comment">// 所有的非叶子节点，root节点在末尾</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Rectangle&gt; leaves_;  <span class="comment">// 叶子节点的最小外接矩形，和leaf_ids_ 一一对应</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; leaf_ids_;      <span class="comment">// 和leaves_ 一一对应</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>这个希尔伯特RTree有如下特点：</p><ol><li>只支持批量加载，不支持插入和删除。</li><li>各节点的空间利用率接近100%，节省内存。</li><li>内存是连续的，可以直接将内存镜像写入文件，序列化和反序列化的速度很快。</li><li>同一节点下的各子节点相邻，查询效率较高。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先考虑一个常见的问题：如何搜索附近的人（车、银行、餐厅等）？&lt;br&gt;可以把这类问题抽象成：快速搜索二维（或者高维）空间上某一指定区域内的数据。&lt;br&gt;很明显，简单的二叉树或者哈希表解决不了这个问题。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="空间索引 rtree" scheme="http://hanyunqi.me/public/tags/%E7%A9%BA%E9%97%B4%E7%B4%A2%E5%BC%95-rtree/"/>
    
  </entry>
  
  <entry>
    <title>C++ 捕获异常时的栈信息</title>
    <link href="http://hanyunqi.me/2017/12/12/C-%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8%E6%97%B6%E7%9A%84%E6%A0%88%E4%BF%A1%E6%81%AF/"/>
    <id>http://hanyunqi.me/2017/12/12/C-%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8%E6%97%B6%E7%9A%84%E6%A0%88%E4%BF%A1%E6%81%AF/</id>
    <published>2017-12-12T10:26:43.000Z</published>
    <updated>2019-05-28T03:32:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于种种原因，我还是不太推荐在C++使用异常机制。所以也不捕获异常，如果有问题直接让它挂掉。<br>最近遇到一个问题，我的框架“帮”我捕获了vector抛出的越界异常，没有了core文件，很难定位问题具体出在哪一行。<br><a id="more"></a><br>backtrace 是可以捕获的栈信息的，但是捕获到异常时已经丢失栈信息了。<br>__cxa_throw 是在抛出异常时被调用的函数，在这个函数中可以捕获栈信息。</p><p>示例代码如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">extern "C" &#123;</div><div class="line">  void __cxa_throw(void *ex, void *info, void (*dest)(void *)) &#123;</div><div class="line">    last_size = backtrace(last_frames, sizeof last_frames/sizeof(void*));</div><div class="line"></div><div class="line">    static void (*const rethrow)(void*,void*,void(*)(void*)) __attribute__ ((noreturn)) = (void (*)(void*,void*,void(*)(void*)))dlsym(RTLD_NEXT, "__cxa_throw");</div><div class="line">    rethrow(ex,info,dest);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="这段代码比较有趣，先是重载了-cxa-throw这个函数，然后又通过dlsym找到原函数。"><a href="#这段代码比较有趣，先是重载了-cxa-throw这个函数，然后又通过dlsym找到原函数。" class="headerlink" title="这段代码比较有趣，先是重载了__cxa_throw这个函数，然后又通过dlsym找到原函数。"></a>这段代码比较有趣，先是重载了__cxa_throw这个函数，然后又通过dlsym找到原函数。</h4><p>这种做法虽然不是很好，但对于我这种不使用异常的人很合适。</p><h4 id="完整的代码："><a href="#完整的代码：" class="headerlink" title="完整的代码："></a>完整的代码：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;dlfcn.h&gt;</div><div class="line">#include &lt;execinfo.h&gt;</div><div class="line">#include &lt;typeinfo&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;memory&gt;</div><div class="line">#include &lt;cxxabi.h&gt;</div><div class="line">#include &lt;cstdlib&gt;</div><div class="line"></div><div class="line">namespace &#123;</div><div class="line">  void * last_frames[100];</div><div class="line">  size_t last_size;</div><div class="line">  std::string exception_name;</div><div class="line"></div><div class="line">  std::string demangle(const char *name) &#123;</div><div class="line">    int status;</div><div class="line">    std::unique_ptr&lt;char,void(*)(void*)&gt; realname(abi::__cxa_demangle(name, 0, 0, &amp;status), &amp;std::free);</div><div class="line">    return status ? "failed" : &amp;*realname;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">extern "C" &#123;</div><div class="line">  void __cxa_throw(void *ex, void *info, void (*dest)(void *)) &#123;</div><div class="line">    exception_name = demangle(reinterpret_cast&lt;const std::type_info*&gt;(info)-&gt;name());</div><div class="line">    last_size = backtrace(last_frames, sizeof last_frames/sizeof(void*));</div><div class="line"></div><div class="line">    static void (*const rethrow)(void*,void*,void(*)(void*)) __attribute__ ((noreturn)) = (void (*)(void*,void*,void(*)(void*)))dlsym(RTLD_NEXT, "__cxa_throw");</div><div class="line">    rethrow(ex,info,dest);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void foo() &#123;</div><div class="line">  throw 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line">  try &#123;</div><div class="line">    foo();</div><div class="line">  &#125;</div><div class="line">  catch (...) &#123;</div><div class="line">    std::cerr &lt;&lt; "Caught a: " &lt;&lt; exception_name &lt;&lt; std::endl;</div><div class="line">    // print to stderr</div><div class="line">    backtrace_symbols_fd(last_frames, last_size, 2);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="编译、执行后会输出："><a href="#编译、执行后会输出：" class="headerlink" title="编译、执行后会输出："></a>编译、执行后会输出：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">g++ -std=c++0x -g -rdynamic -ldl  test.cpp</div><div class="line"></div><div class="line">./a.out</div><div class="line">Caught a: int</div><div class="line">./a.out(__cxa_throw+0x82)[0x401e8a]</div><div class="line">./a.out(main+0x0)[0x401f18]</div><div class="line">./a.out(main+0xc)[0x401f24]</div><div class="line">/lib64/libc.so.6(__libc_start_main+0xfd)[0x3b6641ed5d]</div><div class="line">./a.out[0x401c69]</div></pre></td></tr></table></figure><h4 id="然后使用-addr2line-命令可以定位到代码中的位置。"><a href="#然后使用-addr2line-命令可以定位到代码中的位置。" class="headerlink" title="然后使用 addr2line 命令可以定位到代码中的位置。"></a>然后使用 addr2line 命令可以定位到代码中的位置。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">addr2line 0x401f24 -e ./a.out</div><div class="line"></div><div class="line">./test.cpp:38</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于种种原因，我还是不太推荐在C++使用异常机制。所以也不捕获异常，如果有问题直接让它挂掉。&lt;br&gt;最近遇到一个问题，我的框架“帮”我捕获了vector抛出的越界异常，没有了core文件，很难定位问题具体出在哪一行。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="c++" scheme="http://hanyunqi.me/public/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>使用shadowsocks + vps科学上网</title>
    <link href="http://hanyunqi.me/2017/08/11/shadowsocks/"/>
    <id>http://hanyunqi.me/2017/08/11/shadowsocks/</id>
    <published>2017-08-11T07:53:25.000Z</published>
    <updated>2019-05-28T03:32:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于众所周知的原因，出现了“科学上网”这门技术。<br>由于VPN、ssh等在建立连接或通信是存在明显的特征，容易被针对，而且不是为“墙”而生的，在使用上多少有些蹩脚。所以shadowsocks应运而生。<br><a id="more"></a></p><p>shadowsocks存在以下优点：</p><ol><li>通信时没有握手阶段，不容易被针对。</li><li>使用“智能代理”的方式，避免影响国内网站的访问。</li><li>支持iOS、安卓、Windows、macOS、OpenWRT等各种平台。</li><li>使用方便，一劳永逸。</li></ol><h2 id="购买VPS"><a href="#购买VPS" class="headerlink" title="购买VPS"></a>购买VPS</h2><p>现在市面上的VPS提供商有好多，推荐使用老牌、稳定的<a href="https://www.linode.com/?r=524c694d5f90ed82f7f4a48caec1d34d65a6cef4" target="_blank" rel="external">Linode</a>，每月5$。</p><p><a href="https://www.linode.com/?r=524c694d5f90ed82f7f4a48caec1d34d65a6cef4" target="_blank" rel="external">点击链接</a>，创建账户，充值后就可以使用了。支持信用卡和PayPal。</p><h2 id="搭建shadowsocks服务"><a href="#搭建shadowsocks服务" class="headerlink" title="搭建shadowsocks服务"></a>搭建shadowsocks服务</h2><p>网上可搜到很多如何搭建shadowsocks服务的博文，这里就不赘述了。<br>不过有几点需要提醒的：</p><ol><li>shadowsocks有多用户的配置方法。一台VPS只给自己翻墙用太浪费了，可以分享给身边的朋友。这时多用户的优势就体现出来了！</li><li>为了安全，配置防火墙还是必要的。屏蔽所有端口，使用白名单的方式开放需要的端口。</li><li>禁止root用户通过ssh登录。</li><li>修改ssh的端口，默认是22。</li><li>用supervisor启动shadowsocks还是不错的。注意配置“user=nobody”。</li><li>有kcptun、BBR等用来加速的黑科技可以选择。</li></ol><h2 id="配置客户端"><a href="#配置客户端" class="headerlink" title="配置客户端"></a>配置客户端</h2><p>这个网上也有很多，不赘述了。<br>同样有几点建议：</p><ol><li>可以设置开机自启动。</li><li>可以自定义代理规则。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/shadowsocks/shadowsocks/wiki" target="_blank" rel="external">https://github.com/shadowsocks/shadowsocks/wiki</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于众所周知的原因，出现了“科学上网”这门技术。&lt;br&gt;由于VPN、ssh等在建立连接或通信是存在明显的特征，容易被针对，而且不是为“墙”而生的，在使用上多少有些蹩脚。所以shadowsocks应运而生。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="linux" scheme="http://hanyunqi.me/public/tags/linux/"/>
    
      <category term="shadowsocks" scheme="http://hanyunqi.me/public/tags/shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>使用共享内存加速加载静态数据</title>
    <link href="http://hanyunqi.me/2017/08/11/mmap-load-data/"/>
    <id>http://hanyunqi.me/2017/08/11/mmap-load-data/</id>
    <published>2017-08-11T07:05:14.000Z</published>
    <updated>2019-05-28T03:32:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前遇见一个问题，程序启动时要加载大量的静态数据，导致启动速度很慢。<br><a id="more"></a><br>这带来了两个弊端：</p><ol><li>线上服务的重启成本太高，发布更新时服务不可用的时间较长。</li><li>增加开发调试的成本。</li></ol><p>将需要加载的数据放在tmpfs中，程序启动时用mmap挂载内存，可以达到“零”秒启动的效果。</p><p>如果是map、unordered_map等比较复杂的数据结构，则需要重新组织一下。<br>比如：map可以用二分查找代替，unordered_map也可以映射到线性地址空间上。</p><p>关于运行效率，由于是静态数据，所以就不存在竞争写数据的问题，读取速度和堆上的内存几乎没差别。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h3><ol><li>启动速度快，数据加载时间几乎为零。</li><li>可以解决多进程时加载重复的数据复本，从而节省内存。</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h3><ol><li>需要将数据提前放到tmpfs下。</li><li>程序退出时也不能释放内存，需要手动释放。</li><li>可能需要重新组织数据结构。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前遇见一个问题，程序启动时要加载大量的静态数据，导致启动速度很慢。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="linux" scheme="http://hanyunqi.me/public/tags/linux/"/>
    
      <category term="mmap" scheme="http://hanyunqi.me/public/tags/mmap/"/>
    
  </entry>
  
  <entry>
    <title>Centos下普通用户安装软件包</title>
    <link href="http://hanyunqi.me/2017/07/10/yumdownloader/"/>
    <id>http://hanyunqi.me/2017/07/10/yumdownloader/</id>
    <published>2017-07-10T02:27:26.000Z</published>
    <updated>2019-05-28T03:33:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>在centos下，普通用户（没有root权限）安装软件的方法。<br><a id="more"></a></p><h2 id="yum资源或rpm包"><a href="#yum资源或rpm包" class="headerlink" title="yum资源或rpm包"></a>yum资源或rpm包</h2><p>以安装ag为例<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/<span class="built_in">local</span></div><div class="line"></div><div class="line">yumdownloader pcre-devel xz-devel the_silver_searcher </div><div class="line">rpm2cpio * | cpio -divm</div></pre></td></tr></table></figure></p><h2 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h2><figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">./configure --prefix=$HOME/<span class="keyword">local</span>/</div><div class="line"><span class="built_in">make</span></div><div class="line"><span class="built_in">make</span> install</div></pre></td></tr></table></figure><p>所有程序都安装到了$HOME/local/usr/目录下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在centos下，普通用户（没有root权限）安装软件的方法。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="linux" scheme="http://hanyunqi.me/public/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>机械硬盘写入性能分析</title>
    <link href="http://hanyunqi.me/2017/04/24/hard-disk-io/"/>
    <id>http://hanyunqi.me/2017/04/24/hard-disk-io/</id>
    <published>2017-04-24T09:39:40.000Z</published>
    <updated>2019-05-28T03:33:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在SSD越来越普遍了，貌似现在写这个有点晚了。<br>但是，在一些大批量写入的场景下，机械硬盘的性价比还是比较突出的。<br>或许有一天，机械硬盘会和软盘一样被遗弃，成为历史。<br><a id="more"></a></p><h2 id="机械硬盘工作原理"><a href="#机械硬盘工作原理" class="headerlink" title="机械硬盘工作原理"></a>机械硬盘工作原理</h2><h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><img src="/images/hard-disk.jpg" class="[class name]"><img src="/images/hard-disk2.jpg" class="[class name]"><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>在老式的机械硬盘中，每个磁道上的扇区数相同，也就是内侧（靠近转轴）磁道上的扇区较短（密集），而外侧磁道上的扇区较长（稀疏）。这样的优点是寻址（seek）时方便，缺点时浪费空间，因为外侧磁道上可以存放更多的扇区。<br>所以，在新式的机械硬盘中，外侧磁道上的扇区数比内侧的多。也就使得<strong>外侧磁道上读写速度大于内侧磁道</strong>。</p><h2 id="写入性能"><a href="#写入性能" class="headerlink" title="写入性能"></a>写入性能</h2><ul><li>磁盘寻道</li><li>系统调用</li><li>内存拷贝</li><li>队列深度</li><li>BLOCK SIZE</li><li>CHACHE</li></ul><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><img src="/images/file-system.gif" class="[class name]"><p>Linux系统分用户空间和内核空间，一次写入操作需要把用户空间的数据通过系统调用拷贝到内核空间，再由内核调度写入磁盘。<br>一般系统调用和内存拷贝都需要消耗较多的CPU时间。</p><h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><h3 id="阻塞-I-O"><a href="#阻塞-I-O" class="headerlink" title="阻塞 I/O"></a>阻塞 I/O</h3><img src="/images/blocking-io.png" class="[class name]"><p>典型的阻塞式I/O就是直接通过write系统调用写数据。</p><h3 id="非阻塞-I-O"><a href="#非阻塞-I-O" class="headerlink" title="非阻塞 I/O"></a>非阻塞 I/O</h3><img src="/images/unblocking-io.png" class="[class name]"><p>非阻塞式I/O和阻塞式I/O的区别就是，非阻塞式I/O的请求会立即返回，而不必等待写入操作完成再返回。</p><h3 id="同步-I-O"><a href="#同步-I-O" class="headerlink" title="同步 I/O"></a>同步 I/O</h3><h3 id="异步-I-O"><a href="#异步-I-O" class="headerlink" title="异步 I/O"></a>异步 I/O</h3><img src="/images/asynchronous-io.png" class="[class name]"><p>在Linux系统上有POSIX AIO和libaio两种异步I/O方式。<br>POSIX AIO是一个在多个线程中执行正常阻塞I / O的用户级实现,因此给出了I / O是异步的错觉。<br>Libaio是异步I / O操作的内核支持，其中io请求实际上在内核中排队，根据您拥有的磁盘调度程序排序, (使用TCQ或NCQ)作为异步操作转发(以某种最佳顺序希望)到实际磁盘。<br>所以从性能的角度考虑，libaio更好一些。</p><h2 id="写入方式"><a href="#写入方式" class="headerlink" title="写入方式"></a>写入方式</h2><h3 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h3><p>更加通用的方式，通过在用户空间准备缓冲区，减少系统调用。这种做法一般情况下都会有不错的性能表现。但在高速写入的场景下CPU会成为瓶颈，因为多做了一次内存拷贝。</p><h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><p>将用户空间和内核空间做映射，以减少内存拷贝。而且特别适合随机读写。</p><h3 id="DIO"><a href="#DIO" class="headerlink" title="DIO"></a>DIO</h3><p>绕过内核缓冲区，直接写入磁盘的方式。这是一把双刃剑，使用起来比较麻烦，而且处理不当的话反而会更慢。</p><h3 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h3><p>配合DIO可以达到最大性能。</p><h2 id="测试与监控工具"><a href="#测试与监控工具" class="headerlink" title="测试与监控工具"></a>测试与监控工具</h2><h3 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h3><p>比较专业的系统I/O观测工具。<br><a href="http://hedengcheng.com/?p=687" target="_blank" rel="external">排队论</a></p><h3 id="iotop"><a href="#iotop" class="headerlink" title="iotop"></a>iotop</h3><p>类似于top命令，方便观测实时I/O速度。</p><h3 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h3><p>简单的写入性能测试工具。</p><h3 id="fio"><a href="#fio" class="headerlink" title="fio"></a>fio</h3><p>可以测试硬盘的极限性能。</p><h2 id="极限写入性能"><a href="#极限写入性能" class="headerlink" title="极限写入性能"></a>极限写入性能</h2><p>使用DIO + AIO + 多线程的方式可以达到极限性能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在SSD越来越普遍了，貌似现在写这个有点晚了。&lt;br&gt;但是，在一些大批量写入的场景下，机械硬盘的性价比还是比较突出的。&lt;br&gt;或许有一天，机械硬盘会和软盘一样被遗弃，成为历史。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="c++" scheme="http://hanyunqi.me/public/tags/c/"/>
    
      <category term="linux" scheme="http://hanyunqi.me/public/tags/linux/"/>
    
      <category term="io" scheme="http://hanyunqi.me/public/tags/io/"/>
    
  </entry>
  
  <entry>
    <title>git 简洁提交——合并多个commit</title>
    <link href="http://hanyunqi.me/2017/04/10/git-squash/"/>
    <id>http://hanyunqi.me/2017/04/10/git-squash/</id>
    <published>2017-04-10T13:18:09.000Z</published>
    <updated>2019-05-28T03:32:29.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本地开发，服务器上编译、运行。</li><li>多台电脑间同步代码</li><li>不放心本地，为了备份经常push到代码服务器上。</li></ul><p>因为以上等原因，我需要经常执行git commit，这就导致git的历史中包含很多无效的提交。<br>简洁的git log和工整的代码同样重要，所以我需要合并多个commit。<br><a id="more"></a></p><h2 id="简洁提交"><a href="#简洁提交" class="headerlink" title="简洁提交"></a>简洁提交</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git checkout master</div><div class="line">git merge --squash feature</div><div class="line">git commit</div><div class="line">git push</div></pre></td></tr></table></figure><p><strong> squash命令可以将整个feature分支压缩为master分支上的一个commit。</strong></p><p>下面这条命令也可以达到类似的效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git merge --no-ff --no-commit</div></pre></td></tr></table></figure></p><p>但还是有一点细微的差别，<a href="http://stackoverflow.com/questions/11983749/what-are-the-differences-between-squash-and-no-ff-no-commit" target="_blank" rel="external">请参考这里</a>。</p><h2 id="修改提交历史"><a href="#修改提交历史" class="headerlink" title="修改提交历史"></a>修改提交历史</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git rebase -i HEAD~5</div></pre></td></tr></table></figure><p>-i, –interactive表示使用“交互式”的方法修改。这个命令会列出最近5个commit。<br>大致如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">pick 6e53cd0 update</div><div class="line">pick 446e6ce update</div><div class="line">pick b1ec2c4 update</div><div class="line">pick 366dfac update</div><div class="line">pick 04bf27b for clear script</div><div class="line"></div><div class="line"># Rebase 574d47f..04bf27b onto 574d47f (5 command(s))</div><div class="line">#</div><div class="line"># Commands:</div><div class="line"># p, pick = use commit</div><div class="line"># r, reword = use commit, but edit the commit message</div><div class="line"># e, edit = use commit, but stop for amending</div><div class="line"># s, squash = use commit, but meld into previous commit</div><div class="line"># f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message</div><div class="line"># x, exec = run command (the rest of the line) using shell</div><div class="line"># d, drop = remove commit</div><div class="line">#</div><div class="line"># These lines can be re-ordered; they are executed from top to bottom.</div><div class="line">#</div><div class="line"># If you remove a line here THAT COMMIT WILL BE LOST.</div><div class="line">#</div><div class="line"># However, if you remove everything, the rebase will be aborted.</div><div class="line">#</div><div class="line"># Note that empty commits are commented out</div></pre></td></tr></table></figure><p>将pick改squash或fixup就可以将对应的commit合并到前一个commit中。<br>区别是squash会保留commit message而fixup不会。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">pick 6e53cd0 update</div><div class="line">f 446e6ce update</div><div class="line">f b1ec2c4 update</div><div class="line">f 366dfac update</div><div class="line">pick 04bf27b for clear script</div></pre></td></tr></table></figure><p>保存退出后就会生效。</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;本地开发，服务器上编译、运行。&lt;/li&gt;
&lt;li&gt;多台电脑间同步代码&lt;/li&gt;
&lt;li&gt;不放心本地，为了备份经常push到代码服务器上。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为以上等原因，我需要经常执行git commit，这就导致git的历史中包含很多无效的提交。&lt;br&gt;简洁的git log和工整的代码同样重要，所以我需要合并多个commit。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="git" scheme="http://hanyunqi.me/public/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>一个程序员的Mac环境配置</title>
    <link href="http://hanyunqi.me/2016/05/10/mac-setup/"/>
    <id>http://hanyunqi.me/2016/05/10/mac-setup/</id>
    <published>2016-05-10T13:18:09.000Z</published>
    <updated>2019-05-28T03:34:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>第一篇博客，就从环境配置开始写起吧。<br>大学时靠父母有了人生第一台笔记本，配置还不如现在的手机，但足以满足我对电脑的好奇。<br>从XP开始，到Ubuntu，再到现在的Mac。<br>Mac不仅“秀外”而且“慧中”。能让我在写一天代码之后感到身心愉悦。<br><a id="more"></a></p><h2 id="翻墙"><a href="#翻墙" class="headerlink" title="翻墙"></a>翻墙</h2><p>我现在用的是<a href="https://theqingyun.net" target="_blank" rel="external">轻云</a>，用起来很舒服，但是就快停止服务了。<br>请诸位各显神通，不过还是推荐付费的方式，它会为你节省很多时间。<br>时间就是金钱。</p><h2 id="推荐软件"><a href="#推荐软件" class="headerlink" title="推荐软件"></a>推荐软件</h2><h3 id="HomeBrew"><a href="#HomeBrew" class="headerlink" title="HomeBrew"></a><a href="https://brew.sh/index_zh-cn.html" target="_blank" rel="external">HomeBrew</a></h3><p>HomeBrew 是macOS 不可或缺的套件管理器。<br>类似与yum、apt-get等。</p><h3 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a><a href="https://www.iterm2.com" target="_blank" rel="external">iTerm2</a></h3><p>iTerm2 is a terminal emulator for macOS that does amazing things.<br>macOS上最好的终端了。</p><h3 id="“Oh-My-ZSH-”"><a href="#“Oh-My-ZSH-”" class="headerlink" title="“Oh My ZSH!”"></a><a href="http://ohmyz.sh" target="_blank" rel="external">“Oh My ZSH!”</a></h3><p>“Oh My ZSH!” Your terminal never felt this good before.<br>私人使用时可以用zsh替代bash</p><h3 id="Dropbox"><a href="#Dropbox" class="headerlink" title="Dropbox"></a><a href="http://dropbox.com" target="_blank" rel="external">Dropbox</a></h3><p>我私人的Mac需要和公司的Mac同步配置文件等。<br>以前都用<a href="http://github.com" target="_blank" rel="external">github</a>保存配置文件，但每次都要push和pull，好烦。<br>用了Dropbox后，感觉两台电脑可以无缝切换，自动同步文件。</p><h3 id="spacemacs"><a href="#spacemacs" class="headerlink" title="spacemacs"></a><a href="https://github.com/syl20bnr/spacemacs" target="_blank" rel="external">spacemacs</a></h3><p>传言“vim是编辑器之神，emacs是神的编辑器”。<br>而spacemacs这是emacs之上的vim，集合了二者的优点。</p><p>之前用vim，是vim让我放弃了eclipse。但是vim用久了感觉有些焦躁，插件装多了会很慢。<br>我现在用spacemacs，用两个词形容就是行云流水，思行合一。<br>不是说vim不好，spacemacs也是吸纳了vim的优点。</p><h3 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a><a href="https://tmux.github.io" target="_blank" rel="external">tmux</a></h3><p>tmux is a terminal multiplexer.</p><p>我做服务端开发，线上线下服务器，每天同时活跃的ssh登录有几十个。<br>tmux可以让我快速的在窗口之间跳跃（一个iTerm2窗口打开9个tab，每个tab中的tmux又可以打开10个tmux的tab，90个tab间切换的时间复杂度为O(1)，足够满足我的需求了）。<br>而且可以保持登录的session。<br>白天用公司的Mac工作，晚上到家，打开自己的Mac可以继续服务器上的session工作。<br>节省了很多时间，而且让我更专注于工作内容，让人心情愉悦。</p><h3 id="Alfred"><a href="#Alfred" class="headerlink" title="Alfred"></a><a href="https://www.alfredapp.com" target="_blank" rel="external">Alfred</a></h3><p>Alfred is an award-winning app for Mac OS X which boosts your efficiency with hotkeys, keywords, text expansion and more. Search your Mac and the web, and be more productive with custom actions to control your Mac.</p><p>通过指令快速的在程序之间切换。<br>现在macOS自带的Spotlight也不错。</p><h3 id="VirtualBox"><a href="#VirtualBox" class="headerlink" title="VirtualBox"></a><a href="https://www.virtualbox.org" target="_blank" rel="external">VirtualBox</a></h3><p>虚拟机没什么好的了。<br>macOS虽然是类Unix内核，但还是和Linux有很大区别的。装虚拟机就为了做开发或者实验环境。<br>虚拟机上配置双网卡，一个用来访问外网，一个用来和macOS通信。<br>开启ssh服务，共享文件等设置，物理机和虚拟机傻傻分不清楚，有事我真的觉得我的Mac可以做Linux开发。</p><h3 id="git"><a href="#git" class="headerlink" title="git"></a><a href="https://git-scm.com" target="_blank" rel="external">git</a></h3><p>git不只可以管理代码，也可以管理文档，配置文件等。<br>新手推荐<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰的git教程</a>。</p><h2 id="使用习惯"><a href="#使用习惯" class="headerlink" title="使用习惯"></a>使用习惯</h2><ol><li>Mac的键盘和触摸板要比外接的键盘鼠标更高效。</li><li>尽量使用快捷键。</li><li>后台可以跑很多进程，但要尽量隐藏不关心的内容，以免分散注意力和精力。</li><li>重复性的工作可以考虑写脚本来完成。</li><li>KISS原则：Keep It Simple, Stupid。</li></ol><img src="/images/my-spacemacs.png" class="[class name]">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一篇博客，就从环境配置开始写起吧。&lt;br&gt;大学时靠父母有了人生第一台笔记本，配置还不如现在的手机，但足以满足我对电脑的好奇。&lt;br&gt;从XP开始，到Ubuntu，再到现在的Mac。&lt;br&gt;Mac不仅“秀外”而且“慧中”。能让我在写一天代码之后感到身心愉悦。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="mac" scheme="http://hanyunqi.me/public/tags/mac/"/>
    
  </entry>
  
</feed>
