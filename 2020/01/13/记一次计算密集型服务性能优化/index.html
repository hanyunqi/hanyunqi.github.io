<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>记一次计算密集型服务的性能优化 | hanyunqi的博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-104673368-1','auto');ga('send','pageview');
</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">记一次计算密集型服务的性能优化</h1><a id="logo" href="/.">hanyunqi的博客</a><p class="description">Keep It Simple, Stupid!</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">记一次计算密集型服务的性能优化</h1><div class="post-meta">Jan 13, 2020</div><a class="disqus-comment-count" data-disqus-identifier="2020/01/13/记一次计算密集型服务性能优化/" href="/2020/01/13/记一次计算密集型服务性能优化/#disqus_thread"></a><div class="post-content"><p>性能优化是一个庞杂的话题，不同的场景，不同的视角都会得到不同的理解。<br>比如：有的为了提高吞吐，有的为了降低延迟，有的为了节省资源。<br>他们并不是同一个问题，有时可以牺牲一定的延迟来换取更高的吞吐，比如批量处理；<br>有时可以用更多的存储空间来换取更低的延迟，比如哈希表……</p>
<p>本文讲述的是对计算密集型服务提高吞吐和降低延迟的优化经验和理解。</p>
<h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>这是微服务框架下的一个末端计算节点，使用C++编写，只有一个上游调用方，没有下游。<br>不使用数据库等外部存储，所有数据都在内存中（约占用45GB内存）。<br>使用Thrift ThreadPool框架，接收到请求后，根据内存中的数据做“简单”计算后打成ProtoBuffer包返回给调用方。</p>
<p><strong>在48核物理机上，优化前极限QPS是3.5k左右，优化后的极限QPS超过14k，性能提升4倍。</strong></p>
<h1 id="二、方法论"><a href="#二、方法论" class="headerlink" title="二、方法论"></a>二、方法论</h1><p>性能优化也可以从不同层面去考虑，比如业务流程、架构设计、硬件配置亦或是代码编写等。<br>本文主要从代码优化的角度来优化性能。</p>
<p>使用perf等工具可以分析出热点代码。<br><strong>根据二八法则，优化20%的代码可以提升80%的性能。</strong><br>所以要先找出瓶颈，然后优化这个瓶颈，然后再找下一个瓶颈……</p>
<img src="/images/2020/性能优化脑图.png" class="[class name]">
<p>如上图，我归纳了一些常见的性能瓶颈。<br>一般极限QPS下如果CPU利用率不高，就要考虑是否有阻塞或者竞争（锁）；<br>如果CPU利用率达到或者接近100%，极限性能还是不高，可以考虑优化流程，算法，去除不必要的内存拷贝，减少堆内存的申请、释放和系统调用等。</p>
<p>当然，有些系统看上去没有明显的瓶颈（没有明显的热点代码），这时候就比较考验工程师对性能优化的理解了。<br>一般可以从精简流程或者使用高效的“方法”替代低效的“方法”入手。<br>比如减少临时对象，使用哈希表替代红黑树，提高缓存利用率等方法。</p>
<img src="/images/2020/linux_kernal_architecture.png" class="[class name]">
<p><strong>做好性能优化的关键是：了解计算机是如何运转的。</strong></p>
<ol>
<li>了解硬件的工作原理，知道哪些操作快哪些些操作慢，比如：相比于内存，磁盘IO的速度比较慢；相比于cache，内存的读写比较慢等等。</li>
<li>在硬件之上要了解操作系统的工作原理，比如：堆内存和栈内存的区别，系统调用和函数调用的区别，锁的实现原理等等。</li>
<li>在操作系统之上要了解编译器和标准库都做了什么。执行一行看似简单的代码计算机要做哪些操作?</li>
<li>再之上就是对算法和业务的理解了。很多时候低效的算法和冗余的业务逻辑才是拖累系统性能的关键。</li>
</ol>
<p><strong>性能优化是一个系统工程，不能一味的追求性能，除了如何优化还要考虑其他问题：</strong></p>
<ol>
<li>是否需要优化？过早的优化是万恶之源。</li>
<li>投入产出比</li>
<li>稳定性，因改造引入的风险</li>
<li>鲁棒性</li>
<li>代码的可读性</li>
<li>维护成本</li>
<li>可扩展性</li>
</ol>
<h1 id="三、第一轮优化——去除IO阻塞"><a href="#三、第一轮优化——去除IO阻塞" class="headerlink" title="三、第一轮优化——去除IO阻塞"></a>三、第一轮优化——去除IO阻塞</h1><p><strong>找到瓶颈，依据数据而不是凭空猜测。</strong></p>
<p>优化前的极限QPS是3.5k，简单分析一下发现总的CPU利用率只有50%左右，推断系统内部有严重的阻塞（条件等待）。<br>常见阻塞原因有IO阻塞和互斥锁，使用<a href="https://linux.die.net/man/1/iostat" target="_blank" rel="external">iostat</a>进一步观察系统状态发现await和iowait都很高，这说明IO阻塞比较严重。<br>因为系统运行时只有写日志会触发IO，所以怀疑是写同步日志造成的IO阻塞。<br>关闭日志后压测发现极限QPS可以达到8k+，这基本可以断定写同步日志对系统性能影响比较大。<br>将同步日志改为异步日志很容易，可是也会带来一些弊端。<br>最严重的就是有丢日志的风险，进程异常退出时可能导致缓存中的日志不能刷到磁盘上。<br>考虑到日志本身价值不大，只有在系统异常退出时（比如OOM），需要日志辅助定位问题。<br>综合考虑后，打算把错误日志记同步日志，其他的记异步日志。<br>这次优化的收益很明显，只修改了日志配置，极限QPS从3.5k提升到7k+。<br>后续打算把访问日志分离出来，也记同步日志，降低丢日志的影响。</p>
<h1 id="四、第二轮优化——代码优化"><a href="#四、第二轮优化——代码优化" class="headerlink" title="四、第二轮优化——代码优化"></a>四、第二轮优化——代码优化</h1><p><strong>二八法则，优先解决头部问题。</strong></p>
<img src="/images/2020/ng_191209_rel.svg" class="[class name]">
<p>火焰图</p>
<p>从火焰图上看到除了malloc和free没有明显的热点代码。<br>压到极限QPS时，总的CPU利用率也只有70%。<br>分析一下malloc的过程，不难发现其内部是有线程锁的。<br>IO阻塞解决后，malloc的阻塞问题就凸显出来了。<br>TCMalloc做了线程级的缓存，理论上可以缓解锁竞争的问题。<br>可是换用TCMalloc后发现性能并没有提升（后来证明是因为未正确编译导致的，这里走了一些弯路），然后就尝试了其他思路，从代码的层面入手。</p>
<p><strong>要了解计算机是如何运行的，知道每行代码都做了什么。</strong></p>
<h2 id="4-1-去除冗余逻辑"><a href="#4-1-去除冗余逻辑" class="headerlink" title="4.1 去除冗余逻辑"></a>4.1 去除冗余逻辑</h2><p>由于历史原因，代码中有一些中间数据结构，数据结构间的转换带来了额外的性能开销。<br>还有一些为记录调试日志的额外操作，比如吧PB序列化成文本或者字符串拼接等。<br>再有就是去除不必要的拷贝和临时变量。</p>
<h2 id="4-2-标准模板-STL-的性能优化"><a href="#4-2-标准模板-STL-的性能优化" class="headerlink" title="4.2 标准模板(STL)的性能优化"></a>4.2 标准模板(STL)的性能优化</h2><p>在代码中没有搜索到太多的malloc/free和new/delete，这和火焰图显示的结果不符。</p>
<p>进一步翻阅代码发现有大量的STL容器（vector、string等）的使用，虽然这些都是在栈上创建的对象，但是他们都会申请堆上的内存。这些容器在增长的时候都可能会重新申请内存，比如vector的push_back()就会因为剩余容量不足导致重新申请内存，而且还可能要触发拷贝。<br>字符串（string）拼接的时候也有类似的问题。<br>这种问题可以同reserve来解决，前提是能预估最大容量。</p>
<p>另外vector的push_back()会多触发一次拷贝，所以用emplace_back()性能会更好一些。</p>
<p>针对调用频繁，size不大的且可以确定的vector，用完全在栈上的对象（我用STL风格的API封装的“数组”）代替。<br>栈内存的申请几乎不消耗时间，只需要移动栈顶指针即可，内存连续，cache利用率也高;<br>而堆内存的申请就比较复杂，可能涉及到线程间的竞争，即使有线程级缓存，也难免会带来额外的计算开销。</p>
<p>iostream用起来很方便，但是性能很糟糕，调用频繁的地方可以用snprintf()代替。</p>
<p>如果可以的话，用unordered_map代替map，用数组代替unordered_map。</p>
<h1 id="五、第三轮优化——减少竞争"><a href="#五、第三轮优化——减少竞争" class="headerlink" title="五、第三轮优化——减少竞争"></a>五、第三轮优化——减少竞争</h1><p>做完第二轮优化，性能提升50%，极限QPS从7k提升到10k+。<br>这时候malloc/free带来的开销就更加突出，而且极限情况下CPU利用率也只有70%。<br>所以锁推断是因为malloc/free中有线程锁，加上STL频繁的申请释放内存导致的。<br>因为TCMalloc有线程级的缓存，可以缓解这一现象，这和第二轮优化中的测试结果不符（因为编译问题导致TCMalloc未能生效）。<br>仔细检查并修正后，性能大幅提升，极限QPS可以超过14k。CPU利用率达到95%左右。</p>
<img src="/images/2020/perf.ng.性能优化后.svg" class="[class name]">
<p>优化后的火焰图</p>
<h1 id="六、还可以做哪些优化"><a href="#六、还可以做哪些优化" class="headerlink" title="六、还可以做哪些优化"></a>六、还可以做哪些优化</h1><p>前三轮优化使性能提升4倍，总体改动量不大，风险也可控，所以产出投入比还是很高的。<br>还有一些可以优化的点，因为改造成本、改造风险、运维成本和收益不够等原因暂时没有实施。</p>
<h2 id="6-1-优化数据结构"><a href="#6-1-优化数据结构" class="headerlink" title="6.1 优化数据结构"></a>6.1 优化数据结构</h2><p>服务会用到大量的静态数据，单份数据超过20GB。这些数据的结构还有优化空间。</p>
<ol>
<li>有些数据用二叉树做索引，如果换成哈希表性能会更好。</li>
<li>数据不够紧凑，还有压缩空间，一般数据越紧凑对cache的利用率也会越高。</li>
</ol>
<h2 id="6-2-优化ProtoBuffer"><a href="#6-2-优化ProtoBuffer" class="headerlink" title="6.2 优化ProtoBuffer"></a>6.2 优化ProtoBuffer</h2><p>ProtoBuffer也会因为频繁的申请/释放小对象导致性能不佳，可以用<a href="https://developers.google.com/protocol-buffers/docs/reference/arenas" target="_blank" rel="external">Arena Allocation</a>优化。</p>
<p>Memory allocation and deallocation constitutes a significant fraction of CPU time spent in protocol buffers code. By default, protocol buffers performs heap allocations for each message object, each of its subobjects, and several field types, such as strings. These allocations occur in bulk when parsing a message and when building new messages in memory, and associated deallocations happen when messages and their subobject trees are freed.</p>
<h2 id="6-3-使用Huge-Page"><a href="#6-3-使用Huge-Page" class="headerlink" title="6.3 使用Huge Page"></a>6.3 使用Huge Page</h2><p><a href="https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt" target="_blank" rel="external">Huge Page</a>，是指的大页内存管理方式。与传统的4KB的普通页管理方式相比，Huge Page管理大内存(8GB以上)更为高效。<br>我们的服务占用40GB以上的内存，所以理论上使用Huge Page会有一定性能提升。<br>不过使用Huge Page也会带来额外的运维成本，也需要综合考虑风险和稳定性等原因。</p>
<img src="/images/2020/huge_page.jpg" class="[class name]">
<p>Huge Page的示意图</p>
<h1 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h1><h2 id="7-1-是否需要优化？"><a href="#7-1-是否需要优化？" class="headerlink" title="7.1 是否需要优化？"></a>7.1 是否需要优化？</h2><p>性能优化是一个复杂的问题，除了如何提高性能还需要从收益、成本、风险等维度综合考虑。<br>尤其要考虑清楚为什么要优化？是否需要优化？产出投入比是否够高？是否有更好的解决方案?</p>
<h2 id="7-2-“上兵伐谋”"><a href="#7-2-“上兵伐谋”" class="headerlink" title="7.2 “上兵伐谋”"></a>7.2 “上兵伐谋”</h2><p>不能上来就扎到代码里，“宏观”上的优化可能会有奇效。</p>
<ol>
<li>流程：业务流程是否可以优化？有时删掉一个冗余的逻辑会有大幅的收益。</li>
<li>算法：在规模较大时，时间复杂度上的差异往往是致命的。</li>
<li>机制：同步OR异步，通知OR轮询，阻塞OR非阻塞等等。机制上的差异是很难弥补的。</li>
<li>取舍：时间和空间互换，吞吐和延迟互换，做出合适的取舍，可以事半功倍。</li>
</ol>
<h2 id="7-3-“其下攻城”"><a href="#7-3-“其下攻城”" class="headerlink" title="7.3 “其下攻城”"></a>7.3 “其下攻城”</h2><p>代码是给人看的，程序还要靠计算机来运行。要知道计算机是如何运行的，知道每行代码背后计算机都做了什么，知道哪些操作快、哪些操作慢，才能做好性能优化。</p>
<img src="/images/2020/linux_performance_tools.jpeg" class="[class name]">
<p>有太多的点不能一一列举，总结一下就是：<strong>理论指导实践，实践检验理论。</strong></p>
</div><div class="tags"><a href="/public/tags/c-linux/">c++ linux</a></div><div class="post-nav"><a class="pre" href="/2019/05/27/rcu/">RCU(Read Copy Update)</a><a class="next" href="/2020/01/31/费曼技巧/">学习方法——费曼技巧</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'http://hanyunqi.me/2020/01/13/记一次计算密集型服务性能优化/';
    this.page.identifier = '2020/01/13/记一次计算密集型服务性能优化/';
    this.page.title = '记一次计算密集型服务的性能优化';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//hanyunqi.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//hanyunqi.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://hanyunqi.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://hanyunqi.me"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/public/tags/空间索引-rtree/" style="font-size: 15px;">空间索引 rtree</a> <a href="/public/tags/c/" style="font-size: 15px;">c++</a> <a href="/public/tags/git/" style="font-size: 15px;">git</a> <a href="/public/tags/linux/" style="font-size: 15px;">linux</a> <a href="/public/tags/io/" style="font-size: 15px;">io</a> <a href="/public/tags/mac/" style="font-size: 15px;">mac</a> <a href="/public/tags/rcu/" style="font-size: 15px;">rcu</a> <a href="/public/tags/mmap/" style="font-size: 15px;">mmap</a> <a href="/public/tags/lock-free/" style="font-size: 15px;">lock-free</a> <a href="/public/tags/shadowsocks/" style="font-size: 15px;">shadowsocks</a> <a href="/public/tags/c-linux/" style="font-size: 15px;">c++ linux</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/01/31/费曼技巧/">学习方法——费曼技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/13/记一次计算密集型服务性能优化/">记一次计算密集型服务的性能优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/27/rcu/">RCU(Read Copy Update)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/25/rcu-cache/">多读场景下的本地缓存</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/03/有趣的代码/">有趣的代码</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/28/singleton/">用C++写一个单例</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/25/hilbert-rtree/">静态的希尔伯特RTree</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/12/C-捕获异常时的栈信息/">C++ 捕获异常时的栈信息</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/11/shadowsocks/">使用shadowsocks + vps科学上网</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/11/mmap-load-data/">使用共享内存加速加载静态数据</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> Recent Comments</i></div><script type="text/javascript" src="//hanyunqi.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://www.linode.com/?r=524c694d5f90ed82f7f4a48caec1d34d65a6cef4" title="购买VPS" target="_blank">购买VPS</a><ul></ul><a href="https://db.tt/TyxIiiNBV3" title="注册Dropbox" target="_blank">注册Dropbox</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">hanyunqi的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>